#include "lib/GlobalVariables.jsx"#include "lib/GlobalUtils.jsx"#include "lib/MyPoint.jsx"#include "lib/LineSegment.jsx"#include "lib/LedWrapper.jsx"#include "lib/Route.jsx"#include "lib/Population.jsx"#include "lib/GA.jsx"#include "lib/PowerPadWrapper.jsx"#include "lib/DrawUtils.jsx"#include "lib/CircuitUtils.jsx"#include "lib/VectorUtils.jsx"app.coordinateSystem = CoordinateSystem.ARTBOARDCOORDINATESYSTEM;var _ALL_LEDS = [];var _ALL_POWERS = [];//get selectedLayer and powerLayervar selectedLayer = doc.activeLayer;var powerLayer;var routeLayerParent = IS_ROUTE_LAYER_AT_TOP ? null : selectedLayer;main();/*****************************************************************************************************************/function main(){          if(selectedLayer == null){        for(var i = 0; i < doc.layers.length; i++){            if(doc.layers[i].name.toUpperCase() == selectedLayerName){                selectedLayer = doc.layers[i];                break;            }        }    }    for(var j=0;j<selectedLayer.layers.length;j++){        if(selectedLayer.layers[j].name.toUpperCase() == powerLayerName){            powerLayer = selectedLayer.layers[j];            i = doc.layers.length;            break;        }    }    //get all grouped objects (LED) on current layer    _ALL_LEDS = [];    _ALL_POWERS = [];        /* Implement selection base ********************/    var sel = doc.selection;    //$.bp();    logTerminalln("sel.length = " + sel.length);    for(var i=0;i<sel.length;i++){        logTerminalln("sel " + i + " " + sel[i].pathItems.length);        if(sel[i].pathItems.length == 4){            //led            _ALL_LEDS.push(new LedWrapper(_ALL_LEDS.length, sel[i]));        }    }    for(var i=0;i<sel.length;i++){        if(sel[i].pathItems.length == 2){            sel[i].name = "POWER";            //power            _ALL_POWERS.push(new PowerPadWrapper(_ALL_LEDS.length + 0, sel[i].pathItems.getByName(POWER_CATHODE_NAME)));            _ALL_POWERS.push(new PowerPadWrapper(_ALL_LEDS.length + 1, sel[i].pathItems.getByName(POWER_ANODE_NAME)));            i = sel.length;            break;        }    }    _ALL_LEDS.push(_ALL_POWERS[1]);        /***********************************************/    var fTSP = new File(currentFilePath + currentFileName + ".tsp");    var bestRoute;    // if .tsp file for this design does not exist, then route tsp, create and write to a .tsp file    if(!isGetTSPRouteFromFile || !fTSP.exists){        var pop = new Population(50, true);        var startTimeGA = getTimeMilli();        var g = new GA();        var prevTotalDistance = -1;        var convergeCount = 0;        logTerminalln("Init distance: " + pop.getFittestRoute().getDistance());        for(var i=0;i<_GA_GENERATION;i++){            pop = g.evolvePopulation(pop);            var curTotalDistance = pop.getFittestRoute().getDistance();            if(curTotalDistance == prevTotalDistance){                convergeCount++;            } else {                prevTotalDistance = curTotalDistance;                convergeCount = 0;            }            if(convergeCount == _GA_CONVERGE_THRESHHOLD){                logTerminalln("Generation count: " + i);                break;            }        }        bestRoute = pop.getFittestRoute();        var endTimeGA = getTimeMilli();        logTerminalln("GA time: " + (endTimeGA - startTimeGA));        //set start of route is anode        var anodeID;        var cathodeID;        var cathodeIndex;        for(var i=0;i<_ALL_POWERS.length;i++){            if(_ALL_POWERS[i].polar == 1){                anodeID = _ALL_POWERS[i].id;                for(var j=0;j<bestRoute.leds.length;j++){                    if(bestRoute.leds[j].id == _ALL_POWERS[i].id){                        bestRoute.shiftSource(j);                        break;                    }                }            } else if(_ALL_POWERS[i].polar == 0){                cathodeID = _ALL_POWERS[i].id;                cathodeIndex = i;            }        }        for(var i=0;i<bestRoute.leds.length;i++){            logTerminalln(bestRoute.leds[i].tag);        }        if(isShowTspRaw){            for(var i=0;i<bestRoute.leds.length-1;i++){                var point1 = [mm2point(bestRoute.leds[i].center.x), mm2point(bestRoute.leds[i].center.y)];                var point2 = [mm2point(bestRoute.leds[(i + 1)].center.x), mm2point(bestRoute.leds[(i + 1)].center.y)];                addStraightLine(selectedLayer, TSP_RAW_ROUTE_LAYER_NAME, point1, point2, blackColor, true);            }        }        //check crosing in TSP, if any, uncross        var isCross = false;        do{            isCross = false;            for(var i=0;i<bestRoute.leds.length-1;i++){                var tmpLine = new LineSegment(bestRoute.leds[i].center, bestRoute.leds[i+1].center);                for(var j=i+1;j<bestRoute.leds.length-1;j++){                    var tmpLine2 = new LineSegment(bestRoute.leds[j].center, bestRoute.leds[j+1].center);                    if(tmpLine.doIntersectWith(tmpLine2)){                        isCross = true;                        logTerminalln("cross detected: " + bestRoute.leds[i].tag + "-" + bestRoute.leds[i+1].tag + " and " + bestRoute.leds[j].tag + "-" + bestRoute.leds[j+1].tag);                        //uncross tmpLine and tmpLine2                        reflectSegment(bestRoute.leds, i+1, j);                                        break;                    }                }                if(isCross){                    break;                }            }        } while(isCross);        var firstEdge = new LineSegment(bestRoute.leds[0].center, bestRoute.leds[1].center);        var lastEdge = new LineSegment(bestRoute.leds[bestRoute.leds.length-1].center, _ALL_POWERS[cathodeIndex].center);        if(firstEdge.doIntersectWith(lastEdge)){            reflectSegment(bestRoute.leds, 1, bestRoute.leds.length-1);        }        bestRoute.leds.push(_ALL_POWERS[cathodeIndex]);        //check for cross after adding cathode powerpad        do{            isCross = false;            for(var i=0;i<bestRoute.leds.length-1;i++){                var tmpLine = new LineSegment(bestRoute.leds[i].center, bestRoute.leds[i+1].center);                for(var j=i+1;j<bestRoute.leds.length-1;j++){                    var tmpLine2 = new LineSegment(bestRoute.leds[j].center, bestRoute.leds[j+1].center);                    if(tmpLine.doIntersectWith(tmpLine2)){                        isCross = true;                        logTerminalln("cross detected: " + bestRoute.leds[i].tag + "-" + bestRoute.leds[i+1].tag + " and " + bestRoute.leds[j].tag + "-" + bestRoute.leds[j+1].tag);                        //uncross tmpLine and tmpLine2                        reflectSegment(bestRoute.leds, i+1, j);                                        break;                    }                }                if(isCross){                    break;                }            }        } while(isCross);        var endTimeTSP = getTimeMilli();        logTerminalln("TSP time: " + (endTimeTSP - startTimeGA));        logTerminalln("After uncross:");        for(var i=0;i<bestRoute.leds.length;i++){            logTerminalln(bestRoute.leds[i].tag);        }        //bestRoute OK        writeTSP(currentFilePath + currentFileName + ".tsp", bestRoute);    } else {        // read .tsp file for TSP route        bestRoute = getRouteFromFile(fTSP, _ALL_LEDS, _ALL_POWERS);    }    //add TSP lines    if(isShowTspRaw){        for(var i=0;i<bestRoute.leds.length-1;i++){            var point1 = [mm2point(bestRoute.leds[i].center.x), mm2point(bestRoute.leds[i].center.y)];            var point2 = [mm2point(bestRoute.leds[(i + 1)].center.x), mm2point(bestRoute.leds[(i + 1)].center.y)];            addStraightLine(selectedLayer, TSP_UCR_ROUTE_LAYER_NAME, point1, point2, blackColor, true);        }    }    //rotate LED to bisector at each nodes    for(var i=1;i<bestRoute.leds.length-1;i++){        logTerminalln("getHorizontalAngle = " + bestRoute.leds[i].getHorizontalAngle());        var point1 = [mm2point(bestRoute.leds[i-1].center.x), mm2point(bestRoute.leds[i-1].center.y)];        var point2 = [mm2point(bestRoute.leds[i].center.x), mm2point(bestRoute.leds[i].center.y)];        var point3 = [mm2point(bestRoute.leds[i+1].center.x), mm2point(bestRoute.leds[i+1].center.y)];        vector1 = [point1[0] - point2[0], point1[1] - point2[1]];        vector2 = [point3[0] - point2[0], point3[1] - point2[1]];        rotateAngle = bisectorVerticalAngle(vector1, vector2) + 90 - bestRoute.leds[i].getHorizontalAngle();        bestRoute.leds[i].rotate(rotateAngle);    }    logTerminalln("Final distance: " + bestRoute.getDistance());    //route anodes, cathodes, flip leds if needed    for(var i=1;i<bestRoute.leds.length-2;i++){        //connect i-th led anode to next led anode        var aa = new LineSegment(bestRoute.leds[i].anode, bestRoute.leds[i+1].anode);        var cc = new LineSegment(bestRoute.leds[i].cathode, bestRoute.leds[i+1].cathode);        if(aa.doIntersectWith(cc)){            //anode and cathode wires are crossed --> flip latter led vertically            bestRoute.leds[i+1].rotate(180);        }        if(isShowDraftRoute){            aa = new LineSegment(bestRoute.leds[i].anode, bestRoute.leds[i+1].anode);            cc = new LineSegment(bestRoute.leds[i].cathode, bestRoute.leds[i+1].cathode);            addStraightLine(routeLayerParent, DRAFT_LAYER_NAME, [mm2point(aa.A.x), mm2point(aa.A.y)], [mm2point(aa.B.x), mm2point(aa.B.y)], routeColors[1], true);            addStraightLine(routeLayerParent, DRAFT_LAYER_NAME, [mm2point(cc.A.x), mm2point(cc.A.y)], [mm2point(cc.B.x), mm2point(cc.B.y)], routeColors[0], true);        }    }    //set inner/outer pad for each LEDs    for(var i=1;i<bestRoute.leds.length-1;i++){        setInnerOuterPad(bestRoute.leds[i], bestRoute.leds[i-1], bestRoute.leds[i+1]);    }    for(var i=1;i<bestRoute.leds.length-1;i++){        var centerVector = (new LineSegment(bestRoute.leds[i-1].center, bestRoute.leds[i].center)).toVector();        bestRoute.leds[i].bisectorAngle = makeAngleAcute(centerVector.getAngleWithVector(bestRoute.leds[i].axis.toVector()));    }    /*Without resistance control on route0 layer*/    if(isShowUncontrolResistanceLayer){        ROUTE_LAYER_NAME = "route0";        // route pair of leds        for(var i=1;i<bestRoute.leds.length-2;i++){            routeLedPairs(bestRoute.leds[i], bestRoute.leds[i+1]);        }        routeLedPower(bestRoute.leds[1],                       bestRoute.leds[0],                       INDEX_ANODE,                       INDEX_IN);        routeLedPower(bestRoute.leds[bestRoute.leds.length-2],                       bestRoute.leds[bestRoute.leds.length-1],                       INDEX_CATHODE,                       INDEX_OUT);        // highlight polar pads        for(var i=1;i<bestRoute.leds.length-1;i++){            addPolygonFrom2LineSegments(routeLayerParent, ROUTE_LAYER_NAME, bestRoute.leds[i].anodePadRect[0], bestRoute.leds[i].anodePadRect[2].revertTranslation(), routeColors[1], false);            addPolygonFrom2LineSegments(routeLayerParent, ROUTE_LAYER_NAME, bestRoute.leds[i].cathodePadRect[0], bestRoute.leds[i].cathodePadRect[2].revertTranslation(), routeColors[0], false);        }    }    /********************************************/    ROUTE_LAYER_NAME = "route";    if(IS_CONTROL_RESISTANCE){        setLedConnectionWidth(bestRoute.leds, DEFAULT_VOLTAGE, DEFAULT_FORWARD_VOLTAGE, DEFAULT_FORWARD_CURRENT);    }    for(var i=1;i<bestRoute.leds.length-1;i++){        logTerminalln(bestRoute.leds[i].tag + " R: " + bestRoute.leds[i].ioR);    }    for(var i=1;i<bestRoute.leds.length-1;i++){        var centerVector = (new LineSegment(bestRoute.leds[i-1].center, bestRoute.leds[i].center)).toVector();        bestRoute.leds[i].bisectorAngle = makeAngleAcute(centerVector.getAngleWithVector(bestRoute.leds[i].axis.toVector()));    }    // route pair of leds    for(var i=1;i<bestRoute.leds.length-2;i++){        // routeLedPairs(bestRoute.leds[i], bestRoute.leds[i+1]);        simpleRouteLedPairs(bestRoute.leds[i], bestRoute.leds[i+1]);    }    // routeLedPower(bestRoute.leds[1],     //               bestRoute.leds[0],     //               INDEX_ANODE,     //               INDEX_IN);    // routeLedPower(bestRoute.leds[bestRoute.leds.length-2],     //               bestRoute.leds[bestRoute.leds.length-1],     //               INDEX_CATHODE,     //               INDEX_OUT);    simpleRouteLedPower(bestRoute.leds[1],                         bestRoute.leds[0],                         INDEX_ANODE,                         INDEX_IN);    simpleRouteLedPower(bestRoute.leds[bestRoute.leds.length-2],                         bestRoute.leds[bestRoute.leds.length-1],                         INDEX_CATHODE,                         INDEX_OUT);    // highlight polar pads    // for(var i=1;i<bestRoute.leds.length-1;i++){    //     addPolygonFrom2LineSegments(routeLayerParent, ROUTE_LAYER_NAME, bestRoute.leds[i].anodePadRect[0], bestRoute.leds[i].anodePadRect[2].revertTranslation(), routeColors[1], false);    //     addPolygonFrom2LineSegments(routeLayerParent, ROUTE_LAYER_NAME, bestRoute.leds[i].cathodePadRect[0], bestRoute.leds[i].cathodePadRect[2].revertTranslation(), routeColors[0], false);    // }    logTerminalln("Finished");}function getRouteFromFile(fTSP, _ALL_LEDS, _ALL_POWERS){    var leds = [];    var curLedName;    fTSP.open("r");    while(curLedName = fTSP.readln()){        for(var i=0;i<_ALL_LEDS.length;i++){            if(_ALL_LEDS[i].tag === curLedName){                leds.push(_ALL_LEDS[i]);            }        }    }    fTSP.close();    leds.push(_ALL_POWERS[INDEX_CATHODE]);    var tspRoute = new Route();    tspRoute.leds = leds;    return tspRoute;}// route pair of 2 consecutive LEDs by connecting anode-anode, cathode-cathodefunction simpleRouteLedPairs(pLed1, pLed2){    if(pLed1.type === NODE_TYPE_POWER || pLed2.type === NODE_TYPE_POWER){        return;    }    // connect anode-anode    var l0 = new LineSegment(pLed1.anodeCenter, pLed2.anodeCenter);    // get shiftVector to make l1 from l0    // project center to line l0    var p = projectPointToLine(pLed1.center, l0);    var shiftVector = new Vector(p.x - pLed1.center.x, p.y - pLed1.center.y);    shiftVector = shiftVector.getUnitVector().multiply(pLed1.ioW[INDEX_ANODE][INDEX_OUT]);        var l1 = l0.linearTranslation(shiftVector);        if(isMeanderLineEnable){        //route        if(pLed1.ioW[INDEX_ANODE][INDEX_OUT] >= DEFAULT_LINE_WIDTH_THRESHHOLD){            addPolygonFrom2LineSegments(routeLayerParent,                                         SIMPLE_ROUTE_LAYER_NAME,                                         l0,                                         l1,                                         routeColors[INDEX_ANODE],                                         false);        } else {            logTerminalln("Draw meanderline here");            meanderLineProfile = getMeanderLineProfile(pLed1.ioW[INDEX_ANODE][INDEX_OUT],                                                        DEFAULT_LINE_WIDTH_THRESHHOLD,                                                       l0.getLength());            drawMeanderLineFromProfile(meanderLineProfile,                                        routeLayerParent,                                        SIMPLE_ROUTE_LAYER_NAME,                                        new MyPoint(l0.A.x, l0.A.y),                                        l0.toVector());        }    } else {        addPolygonFrom2LineSegments(routeLayerParent,                                         SIMPLE_ROUTE_LAYER_NAME,                                         l0,                                         l1,                                         routeColors[INDEX_ANODE],                                         false);    }    // connect cathode-cathode    l0 = new LineSegment(pLed1.cathodeCenter, pLed2.cathodeCenter);    // get shiftVector to make l1 from l0    // project center to line l0    var p = projectPointToLine(pLed1.center, l0);    shiftVector = new Vector(p.x - pLed1.center.x, p.y - pLed1.center.y);    shiftVector = shiftVector.getUnitVector().multiply(pLed1.ioW[INDEX_CATHODE][INDEX_OUT]);        l1 = l0.linearTranslation(shiftVector);    if(isMeanderLineEnable){        if(pLed1.ioW[INDEX_CATHODE][INDEX_OUT] >= DEFAULT_LINE_WIDTH_THRESHHOLD){            addPolygonFrom2LineSegments(routeLayerParent,                                         SIMPLE_ROUTE_LAYER_NAME,                                         l0,                                         l1,                                         routeColors[INDEX_CATHODE],                                         false);        } else {            logTerminalln("Draw meanderline here");            meanderLineProfile = getMeanderLineProfile(pLed1.ioW[INDEX_CATHODE][INDEX_OUT],                                                        DEFAULT_LINE_WIDTH_THRESHHOLD,                                                       l0.getLength());            drawMeanderLineFromProfile(meanderLineProfile,                                        routeLayerParent,                                        SIMPLE_ROUTE_LAYER_NAME,                                        new MyPoint(l0.A.x, l0.A.y),                                        l0.toVector());        }    } else {        addPolygonFrom2LineSegments(routeLayerParent,                                         SIMPLE_ROUTE_LAYER_NAME,                                         l0,                                         l1,                                         routeColors[INDEX_CATHODE],                                         false);    }    // add polygon of anode & cathode terminal    addPolygonFromPoints(routeLayerParent, SIMPLE_ROUTE_LAYER_NAME, pLed1.anodePadRectPoints, routeColors[INDEX_ANODE], false);    addPolygonFromPoints(routeLayerParent, SIMPLE_ROUTE_LAYER_NAME, pLed1.cathodePadRectPoints, routeColors[INDEX_CATHODE], false);}// route pair of 2 consecutive LEDs with additional padsfunction routeLedPairs (pLed1, pLed2) {    if(pLed1.type === NODE_TYPE_POWER || pLed1.type === NODE_TYPE_POWER){        return;    }    var pLeds = [pLed1, pLed2];    var centerLineSegment = new LineSegment(pLed1.center, pLed2.center);    var centerVector = new Vector(pLed2.center.x - pLed1.center.x, pLed2.center.y - pLed1.center.y);    var unitNormalCenterVector = centerVector.getNormal().getUnitVector();    var shiftVector = unitNormalCenterVector.multiply(DEFAULT_LINE_SPACING/2);    var l0 = centerLineSegment.linearTranslation(shiftVector);    var l1 = centerLineSegment.linearTranslation(shiftVector.getReverse());    var v0 = unitNormalCenterVector;    var v1 = unitNormalCenterVector.getReverse();    var l = [l0, l1];    var v = [v0, v1];    var bisectorAngle = [pLeds[0].bisectorAngle, pLeds[1].bisectorAngle];    if(centerLineSegment.isSameSide(l0.A, pLeds[0].anode)){        //l0 is anode, l1 is cathode        l[INDEX_CATHODE] = l1; // [0] as cathode line        l[INDEX_ANODE] = l0; // [1] as anode line        v[INDEX_CATHODE] = v1.multiply(pLeds[0].ioW[INDEX_CATHODE][INDEX_OUT]);        v[INDEX_ANODE] = v0.multiply(pLeds[0].ioW[INDEX_ANODE][INDEX_OUT]);    } else {        //l1 is anode, l0 is cathode        l[INDEX_CATHODE] = l0; // [0] as cathode line        l[INDEX_ANODE] = l1; // [1] as anode line        v[INDEX_CATHODE] = v0.multiply(pLeds[0].ioW[INDEX_CATHODE][INDEX_OUT]);        v[INDEX_ANODE] = v1.multiply(pLeds[0].ioW[INDEX_ANODE][INDEX_OUT]);    }    var ll = [];    ll[INDEX_CATHODE] = l[INDEX_CATHODE].linearTranslation(v[INDEX_CATHODE]);    ll[INDEX_ANODE] = l[INDEX_ANODE].linearTranslation(v[INDEX_ANODE]);    var floatingPoints = [];    floatingPoints.push([getFloatingPoint(pLed1, l[INDEX_CATHODE], v[INDEX_CATHODE], INDEX_CATHODE, INDEX_OUT),                          getFloatingPoint(pLed1, l[INDEX_ANODE], v[INDEX_ANODE], INDEX_ANODE, INDEX_OUT)]);    floatingPoints.push([getFloatingPoint(pLed2, l[INDEX_CATHODE], v[INDEX_CATHODE], INDEX_CATHODE, INDEX_IN),                          getFloatingPoint(pLed2, l[INDEX_ANODE], v[INDEX_ANODE], INDEX_ANODE, INDEX_IN)]);    for(var i=0;i<2;i++){        l[i].A = pointOfIntersect(l[i], pLed1.axis);        l[i].B = pointOfIntersect(l[i], pLed2.axis);        if(bisectorAngle[0] < REFINE_THRESHHOLD_ANGLE){            ll[i].A = floatingPoints[0][i];        } else {            ll[i].A = pointOfIntersect(ll[i], pLeds[0].axis);        }        if(bisectorAngle[1] < REFINE_THRESHHOLD_ANGLE){            ll[i].B = floatingPoints[1][i];        } else {            ll[i].B = pointOfIntersect(ll[i], pLeds[1].axis);        }        var outerCutLine = [getOuterCutLineSegment(pLeds[0], l[i]),                            getOuterCutLineSegment(pLeds[1], l[i])];        if(i === pLeds[0].outerPad && bisectorAngle[0] < REFINE_THRESHHOLD_ANGLE){            if(distancePoint2Point(l[i].A, pLeds[0].center) > distancePoint2Line(pLeds[0].center, outerCutLine[0])){                l[i].A = pointOfIntersect(l[i], outerCutLine[0]);            }            ll[i].A = pointOfIntersect(ll[i], outerCutLine[0]);        }        if(i === pLeds[1].outerPad && bisectorAngle[1] < REFINE_THRESHHOLD_ANGLE){            if(distancePoint2Point(l[i].B, pLeds[1].center) > distancePoint2Line(pLeds[1].center, outerCutLine[1])){                l[i].B = pointOfIntersect(l[i], outerCutLine[1]);            }            ll[i].B = pointOfIntersect(ll[i], outerCutLine[1]);        }        //route        if(pLeds[0].ioW[i][INDEX_OUT] >= DEFAULT_LINE_WIDTH_THRESHHOLD){            addPolygonFrom2LineSegments(routeLayerParent, ROUTE_LAYER_NAME, l[i], ll[i], routeColors[i], false);            } else {            logTerminalln("Draw meanderline here");            meanderLineProfile = getMeanderLineProfile(pLeds[0].ioW[i][INDEX_OUT],                                                        DEFAULT_LINE_WIDTH_THRESHHOLD,                                                       l[i].getLength() >= ll[i].getLength() ? l[i].getLength() : ll[i].getLength());            drawMeanderLineFromProfile(meanderLineProfile,                                        routeLayerParent,                                        ROUTE_LAYER_NAME,                                        new MyPoint(l[i].A.x, l[i].A.y),                                        l[i].toVector());        }        //additional pad        if(i == pLeds[0].outerPad && bisectorAngle[0] < REFINE_THRESHHOLD_ANGLE){            if(distancePoint2Point(l[i].A, pLeds[0].center) > distancePoint2Line(pLeds[0].center, outerCutLine[0])){                addPolygonFromPoints(routeLayerParent, ROUTE_LAYER_NAME, getAdditionalPad(pLeds[0], l[i], outerCutLine[0], i), routeColors[i], false);            } else {                addPolygonFromPoints(routeLayerParent,                                      ROUTE_LAYER_NAME,                                      getOuterTrianglePad(pLeds[0], l[i], v[i], outerCutLine[0], i, INDEX_OUT),                                     routeColors[i],                                      false);                addPolygonFromPoints(routeLayerParent,                                      ROUTE_LAYER_NAME,                                      getAdditionalPad(pLeds[0], l[i], null, i),                                      routeColors[i],                                      false);                }        } else {            addPolygonFromPoints(routeLayerParent, ROUTE_LAYER_NAME, getAdditionalPad(pLeds[0], l[i], null, i), routeColors[i], false);        }    }}function getOuterTrianglePad(pLed, pFirstLineSegment, pShiftVector, pCutLineSegment, pPolar, pDirection){    var triPad = [];    triPad.push(pFirstLineSegment.A);    triPad.push(pointOfIntersect(pFirstLineSegment.linearTranslation(pShiftVector), pCutLineSegment));    var r_l = pFirstLineSegment.getReflectThroughAxis(pLed.axis);    var reflectDirection = Math.abs(pDirection - 1);    var r_v = pShiftVector.reflectThroughLine(pLed.axis)                          .getUnitVector()                          .multiply(pLed.ioW[pPolar][reflectDirection]);    var r_ll = r_l.linearTranslation(r_v);    triPad.push(pointOfIntersect(r_ll, pCutLineSegment));    return triPad;}function getAdditionalPad (pLed, pFirstLineSegment, pCutLineSegment, pPolar) {    var additionalPad = [];    additionalPad.push(pLed.polarsRectPoint[pPolar][0]);    additionalPad.push(pLed.polarsRectPoint[pPolar][1]);    var p1 = pointOfIntersect(pLed.polarsRect[pPolar][2], pFirstLineSegment);    var p2 = pointOfIntersect(pLed.polarsRect[pPolar][2], pFirstLineSegment.getReflectThroughAxis(pLed.axis));    var p = p1;        if(pLed.innerPad === pPolar){        if(distancePoint2Point(p1, pLed.center) <            distancePoint2Point(p2, pLed.center)){            p = p2;        }    } else {        if(distancePoint2Point(p1, pLed.center) >            distancePoint2Point(p2, pLed.center)){            p = p2;        }    }    additionalPad.push(p);    if(pCutLineSegment != null){        var fixingPoint = pointOfIntersect(pFirstLineSegment, pLed.axis);        var cutPoint1 = pointOfIntersect((new LineSegment(p, fixingPoint)), pCutLineSegment);        var cutPoint2 = reflectPointThroughLine(cutPoint1, pLed.axis);        additionalPad.push(cutPoint1);        additionalPad.push(cutPoint2);    } else {        additionalPad.push(pFirstLineSegment.A);    }    additionalPad.push(reflectPointThroughLine(p, pLed.axis));    return additionalPad;}function getWingPoint(pLed, pFirstLineSegment, pPolar){    var p1 = pointOfIntersect(pLed.polarsRect[pPolar][2], pFirstLineSegment);    var p2 = pointOfIntersect(pLed.polarsRect[pPolar][2], pFirstLineSegment.getReflectThroughAxis(pLed.axis));    var p = p1;        if(pLed.innerPad === pPolar){        if(distancePoint2Point(p1, pLed.center) <            distancePoint2Point(p2, pLed.center)){            p = p2;        }    } else {        if(distancePoint2Point(p1, pLed.center) >            distancePoint2Point(p2, pLed.center)){            p = p2;        }    }    return p;}function getOuterCutLineSegment(pLed, pFirstLineSegment){    var polar = pLed.outerPad;    var p = getWingPoint(pLed, pFirstLineSegment, polar);    var p1 = reflectPointThroughLine(p, pLed.axis);    var shiftVector = new Vector(pLed.polarPoint[polar].x - pLed.center.x, pLed.polarPoint[polar].y - pLed.center.y);    shiftVector = shiftVector.getUnitVector().multiply(pLed.getWiderTrace(polar));    return (new LineSegment(p, p1)).linearTranslation(shiftVector);}function simpleRouteLedPower(pLed, pPower, pPolar, pDirection){    var powerLayer = SIMPLE_ROUTE_LAYER_NAME;    if(pPolar === INDEX_CATHODE && pDirection === INDEX_OUT){        // route from the last LEDs to cathode pad of power source        var l0 = new LineSegment(pLed.cathodeCenter, pPower.center);        // get shiftVector to make l1 from l0        // project center to line l0        var p = projectPointToLine(pLed.center, l0);        var shiftVector = new Vector(p.x - pLed.center.x, p.y - pLed.center.y);        shiftVector = shiftVector.getUnitVector().multiply(pLed.ioW[INDEX_CATHODE][INDEX_OUT]);        var l1 = l0.linearTranslation(shiftVector);        addPolygonFrom2LineSegments(routeLayerParent,                                     powerLayer,                                     l0,                                     l1,                                     routeColors[INDEX_CATHODE],                                     false);        // add polygon of anode and cathode terminal for the last LED        addPolygonFromPoints(routeLayerParent, SIMPLE_ROUTE_LAYER_NAME, pLed.anodePadRectPoints, routeColors[INDEX_ANODE], false);        addPolygonFromPoints(routeLayerParent, SIMPLE_ROUTE_LAYER_NAME, pLed.cathodePadRectPoints, routeColors[INDEX_CATHODE], false);    } else if(pPolar === INDEX_ANODE && pDirection === INDEX_IN){        // route from the first LEDs to anode pad of power source        var l0 = new LineSegment(pLed.anodeCenter, pPower.center);        // get shiftVector to make l1 from l0        // project center to line l0        var p = projectPointToLine(pLed.center, l0);        var shiftVector = new Vector(p.x - pLed.center.x, p.y - pLed.center.y);        shiftVector = shiftVector.getUnitVector().multiply(pLed.ioW[INDEX_ANODE][INDEX_IN]);        var l1 = l0.linearTranslation(shiftVector);        addPolygonFrom2LineSegments(routeLayerParent,                                     powerLayer,                                     l0,                                     l1,                                     routeColors[INDEX_ANODE],                                     false);    }    addPolygonFromPoints(routeLayerParent, SIMPLE_ROUTE_LAYER_NAME, pPower.framePoints, routeColors[INDEX_CATHODE], false);}function routeLedPower(pLed, pPower, pPolar, pDirection){    // addPolygonFromPoints(routeLayerParent, ROUTE_LAYER_NAME, pPower.framePoints, routeColors[pPolar], false);    var powerLayer = SIMPLE_ROUTE_LAYER_NAME;    addPolygonFromPoints(routeLayerParent, powerLayer, pPower.framePoints, routeColors[pPolar], false);    var centerLineSegment = new LineSegment(pLed.center, pPower.center);    var centerVector = centerLineSegment.toVector();    var shiftLine = new LineSegment(projectPointToLine(pLed.polarPoint[pPolar], centerLineSegment),                                     pLed.polarPoint[pPolar]);    var unitNormalCenterVector = shiftLine.toVector().getUnitVector();    var shiftVector = unitNormalCenterVector.multiply(DEFAULT_LINE_SPACING/2);    var l = centerLineSegment.linearTranslation(shiftVector);    var v = unitNormalCenterVector.multiply(pLed.ioW[pPolar][pDirection]);    var ll = l.linearTranslation(v);    l.A = pointOfIntersect(l, pLed.axis);    if(pLed.bisectorAngle < REFINE_THRESHHOLD_ANGLE){        ll.A = getFloatingPoint(pLed, l, v, pPolar, pDirection);    } else {        ll.A = pointOfIntersect(ll, pLed.axis);    }    addPolygonFrom2LineSegments(routeLayerParent, powerLayer, l, ll, routeColors[pPolar], false);    if(pPolar === INDEX_CATHODE && pDirection === INDEX_OUT){        //additional pad for Cathode        addPolygonFromPoints(routeLayerParent, powerLayer, getAdditionalPad(pLed, l, null, INDEX_CATHODE), routeColors[INDEX_CATHODE], false);        //additional pad for Anode        var l1 = centerLineSegment.linearTranslation(shiftVector.multiply(-1)).getReflectThroughAxis(pLed.axis);        l1.A = pointOfIntersect(l1, pLed.axis);        var l2 = l1.linearTranslation(shiftVector.multiply(-1).reflectThroughLine(pLed.axis).getUnitVector().multiply(pLed.ioW[INDEX_ANODE][INDEX_IN]));        l2.A = pointOfIntersect(l2, pLed.axis);        var tmpShiftVector = (new LineSegment(projectPointToLine(l2.A, pLed.polarsRect[INDEX_ANODE][1]), l2.A)).toVector();        addPolygonFrom2LineSegments(routeLayerParent, powerLayer,                                     pLed.polarsRect[INDEX_ANODE][1],                                    pLed.polarsRect[INDEX_ANODE][1].linearTranslation(tmpShiftVector),                                    routeColors[INDEX_ANODE],                                    false);    } else if(pPolar === INDEX_ANODE && pDirection === INDEX_IN){        //additional pad for Cathode        var l1 = centerLineSegment.linearTranslation(shiftVector.multiply(-1)).getReflectThroughAxis(pLed.axis);        l1.A = pointOfIntersect(l1, pLed.axis);        var l2 = l1.linearTranslation(shiftVector.multiply(-1).reflectThroughLine(pLed.axis).getUnitVector().multiply(pLed.ioW[INDEX_CATHODE][INDEX_OUT]));        l2.A = pointOfIntersect(l2, pLed.axis);        var tmpShiftVector = (new LineSegment(projectPointToLine(l2.A, pLed.polarsRect[INDEX_CATHODE][1]), l2.A)).toVector();        addPolygonFrom2LineSegments(routeLayerParent, powerLayer,                                     pLed.polarsRect[INDEX_CATHODE][1],                                    pLed.polarsRect[INDEX_CATHODE][1].linearTranslation(tmpShiftVector),                                    routeColors[INDEX_CATHODE],                                    false);    }}function getFloatingPoint(pLed, pFirstLineSegment, pShiftVector, pPolar, pDirection) {    var shiftVectors = [];    shiftVectors[pDirection] = pShiftVector;    var revertDirection = Math.abs(pDirection - 1);    shiftVectors[revertDirection] = pShiftVector.                                    reflectThroughLine(pLed.axis).                                    getUnitVector().                                    multiply(pLed.ioW[pPolar][revertDirection]);    var l = [];    l[pDirection] = pFirstLineSegment;    l[revertDirection] = pFirstLineSegment.getReflectThroughAxis(pLed.axis);    var ll = []    ll[pDirection] = l[pDirection].linearTranslation(shiftVectors[pDirection]);    ll[revertDirection] = l[revertDirection].linearTranslation(shiftVectors[revertDirection]);    return pointOfIntersect(ll[pDirection], ll[revertDirection]);}//set innerPad of centerLed as 1 if anode of center led is inner pad,//set innerPad of centerLed as 0 if cathode of center led is inner padfunction setInnerOuterPad(pCenterLed, pSideLed1, pSideLed2){    var vectorCS1 = {x:pSideLed1.center.x - pCenterLed.center.x, y:pSideLed1.center.y - pCenterLed.center.y};    vectorCS1 = normalizeVector(vectorCS1);    var vectorCS2 = {x:pSideLed2.center.x - pCenterLed.center.x, y:pSideLed2.center.y - pCenterLed.center.y};    vectorCS2 = normalizeVector(vectorCS2);    var vectorBisector = normalizeVector(sumVector(vectorCS1, vectorCS2));    if(angleNormalizedVector(pCenterLed.anodeNormalizedVector, vectorBisector) < angleNormalizedVector(vectorCS1, vectorCS2)){        pCenterLed.innerPad = 1;        pCenterLed.outerPad = 0;    } else {        pCenterLed.innerPad = 0;        pCenterLed.outerPad = 1;    }}function setLedConnectionWidth (pLeds, pVo, pVf, pIf) {    var n = pLeds.length;    var R = (pVo - pVf)/((n-2+1)*pIf);    logTerminalln("R = " + R);    // array contains distance of anode-anode and cathode-cathode between 2 consecutive LEDs    // d[i] = [anode_anode_distance, cathode_cathode_distance]    var d = [];         // To fine-tune routing, get distance equal to distance of anode-anode, cathode-cathode    // distance from power source anode pad to the first LED    d.push([null, distancePoint2Point(pLeds[0].center, pLeds[1].anodeCenter)]);        // distance anode-anode, cathode-cathode between each pair of consecutive LEDs    for(var i=1;i<pLeds.length-2;i++){        // d.push(pLeds[i].distanceTo(pLeds[i+1]));        d.push([distancePoint2Point(pLeds[i].cathodeCenter, pLeds[i+1].cathodeCenter),                 distancePoint2Point(pLeds[i].anodeCenter, pLeds[i+1].anodeCenter)]);    }    // distance from the last LED to power source cathode pad    d.push([distancePoint2Point(pLeds[pLeds.length-2].cathodeCenter, pLeds[pLeds.length-1].center), null]);        for(var i=1;i<=(pLeds.length-1)/2;i++){        // [i] === [length - 1 - i]        // anode in        pLeds[i].ioR[1][1] = R/(n-i);        // anode out        pLeds[i].ioR[1][0] = R/(n-i-1);        // cathode in        pLeds[i].ioR[0][1] = R/(i);        // cathode out        pLeds[i].ioR[0][0] = R/(i+1);        var j = pLeds.length - 1 - i;        // anode in [j] === cathode out [i]        pLeds[j].ioR[1][1] = pLeds[i].ioR[0][0];        // anode out [j] === cathode in [i]        pLeds[j].ioR[1][0] = pLeds[i].ioR[0][1];        // cathode in [j] === anode out [i]        pLeds[j].ioR[0][1] = pLeds[i].ioR[1][0];        // cathode out [j] === anode in [i]        pLeds[j].ioR[0][0] = pLeds[i].ioR[1][1];            }    for(var i=1;i<pLeds.length-1;i++){        pLeds[i].ioW[INDEX_CATHODE][INDEX_IN] = getWidthTraceFrom(pLeds[i].ioR[0][1], d[i-1][INDEX_CATHODE], DEFAULT_SHEET_RESISTANCE);        pLeds[i].ioW[INDEX_ANODE][INDEX_IN] = getWidthTraceFrom(pLeds[i].ioR[1][1], d[i-1][INDEX_ANODE], DEFAULT_SHEET_RESISTANCE);        pLeds[i].ioW[INDEX_CATHODE][INDEX_OUT] = getWidthTraceFrom(pLeds[i].ioR[0][0], d[i][INDEX_CATHODE], DEFAULT_SHEET_RESISTANCE);        pLeds[i].ioW[INDEX_ANODE][INDEX_OUT] = getWidthTraceFrom(pLeds[i].ioR[1][0], d[i][INDEX_ANODE], DEFAULT_SHEET_RESISTANCE);        // pLeds[i].ioW[0][1] = getWidthTraceFrom(DEFAULT_RESISTANCE, d[i-1], DEFAULT_SHEET_RESISTANCE);        // pLeds[i].ioW[1][1] = getWidthTraceFrom(DEFAULT_RESISTANCE, d[i-1], DEFAULT_SHEET_RESISTANCE);        // pLeds[i].ioW[0][0] = getWidthTraceFrom(DEFAULT_RESISTANCE, d[i], DEFAULT_SHEET_RESISTANCE);        // pLeds[i].ioW[1][0] = getWidthTraceFrom(DEFAULT_RESISTANCE, d[i], DEFAULT_SHEET_RESISTANCE);    }}// N: numOfPulse, G: gap, h: pulseHeight, w: oldWidth, w': newWidth, L: distance//     L(w'-w)// N = -------   , N is integer//       2wh // we want w' <= h <= 1mm, N is integer//     L(w'-w)         L(w'-w)// --> ------- <= N <= -------//       2w              2w'w//                                         kL// 2w' + DEFAULT_LINE_MINIMUM_GAP <= G <= ----     , k is a arbitrary number, less than or equal 1//                                         N// spacer S = (L-NG)/(N+1)// we want S = G --> G = L/(2N+1)// as G >= 2w' + DEFAULT_LINE_MINIMUM_GAP --> N <= (L-2w'-DEFAULT_LINE_MINIMUM_GAP)/(4w'+ 2*DEFAULT_LINE_MINIMUM_GAP) (numOfPulseUpperBound1)function getMeanderLineProfile(pOldWidth, pNewWidth, pDistance){    if(pOldWidth >= DEFAULT_LINE_WIDTH_THRESHHOLD || pNewWidth > DEFAULT_LINE_WIDTH_THRESHHOLD){        // invalid width, we just deal with cases where oldWidth is very small, like 0.06mm        return null;    }    var meanderlineProfile = {numOfPulse: 0,                               gap:0,                               pulseHeight:0,                               width:pNewWidth,                               distance: pDistance};    numOfPulseUnderbound = pDistance*(pNewWidth - pOldWidth)/(2*pOldWidth);    numOfPulseUpperbound = pDistance*(pNewWidth - pOldWidth)/(2*pOldWidth*pNewWidth);    numOfPulseUpperbound1 = (pDistance-2*pNewWidth - DEFAULT_LINE_MINIMUM_GAP)/(4*pNewWidth + 2*DEFAULT_LINE_MINIMUM_GAP);    numOfPulseUpperbound = numOfPulseUpperbound > numOfPulseUpperbound1 ?                            numOfPulseUpperbound1 :                            numOfPulseUpperbound;    meanderlineProfile.numOfPulse = Math.floor(numOfPulseUpperbound);    meanderlineProfile.gap = pDistance/(2*meanderlineProfile.numOfPulse + 1);    meanderlineProfile.pulseHeight = pDistance * (pNewWidth - pOldWidth)/                                    (2*pOldWidth*meanderlineProfile.numOfPulse);    return meanderlineProfile;}function normalizeVector(pV){    l = Math.sqrt(pV.x * pV.x + pV.y * pV.y);    var x = pV.x/l;    var y = pV.y/l;    return {x: x, y: y};}function sumVector(pV1, pV2){    return {x:pV1.x + pV2.x, y:pV1.y + pV2.y};}function dotProduct(pV1, pV2){    return pV1.x * pV2.x + pV1.y*pV2.y;}function angleNormalizedVector(pV1, pV2){    return Math.acos(dotProduct(pV1, pV2));}function linearTranslatePoint(pPoint, pV){    return {x: pPoint.x + pV.x, y: pPoint.y + pV.y};}function multiplyVector(pV, pCoef){    return {x:pV.x * pCoef, y:pV.y * pCoef};}function subtractPoints(point1, point2) {    var result = {};    result.x = point1.x - point2.x;    result.y = point1.y - point2.y;    return result;}function equalPoints(point1, point2) {    return (point1.x == point2.x) && (point1.y == point2.y)}function crossProduct(point1, point2) {    return point1.x * point2.y - point1.y * point2.x;}function allEqual(args) {    var firstValue = arguments[0],        i;    for (i = 1; i < arguments.length; i += 1) {        if (arguments[i] != firstValue) {            return false;        }    }    return true;}function pointOfIntersect(l1, l2){    x = ((l1.A.x*l1.B.y - l1.A.y*l1.B.x)*(l2.A.x - l2.B.x) - (l1.A.x - l1.B.x)*(l2.A.x*l2.B.y - l2.A.y*l2.B.x))/        ((l1.A.x - l1.B.x)*(l2.A.y - l2.B.y) - (l1.A.y - l1.B.y)*(l2.A.x - l2.B.x));    y = ((l1.A.x*l1.B.y - l1.A.y*l1.B.x)*(l2.A.y - l2.B.y) - (l1.A.y - l1.B.y)*(l2.A.x*l2.B.y - l2.A.y*l2.B.x))/        ((l1.A.x - l1.B.x)*(l2.A.y - l2.B.y) - (l1.A.y - l1.B.y)*(l2.A.x - l2.B.x));    return {x:x, y:y};}function projectPointToLine(pP, pLineSegment){    var d = pLineSegment.getVector();    var p = pLineSegment.A;    var pP_m = subtractPoints(pP, p);    var a = dotProduct(pP_m, d)/dotProduct(d, d);    return sumVector(p, multiplyVector(d, a));}function reflectPointThroughLine(pP, pLineSegment){    var projectedPoint = projectPointToLine(pP, pLineSegment);    return sumVector(multiplyVector(projectedPoint, 2), multiplyVector(pP, -1));}function reflectVectorThroughLine(pV, pLineSegment){    var vLineSegment = new LineSegment({x:0, y:0}, pV);    return vLineSegment.getReflectThroughAxis(pLineSegment).getVector();}function reflectSegment(pArray, pStart, pEnd){    if(pStart < 0 || pEnd >= pArray.length){        return false;    }    for(var i=pStart;i<=(pEnd + pStart)/2;i++){        var tmp = pArray[i];        pArray[i] = pArray[pEnd - (i-pStart)];        pArray[pEnd - (i-pStart)] = tmp;    }}//find angle made by bisector ray and verital axisfunction bisectorVerticalAngle(pU, pV){    theta_u = Math.atan2(pU[1], pU[0]);    theta_v = Math.atan2(pV[1], pV[0]);    bisectorAngle = (theta_u + theta_v)/2;    return rad2degree(bisectorAngle - (Math.PI)/2);}function getAngleFromVectors(pU, pV){    a = angleNormalizedVector(normalizeVector(pU), normalizeVector(pV));    return rad2degree(a);}