#include "GlobalVariables.jsx"#include "MyPoint.jsx"/*** Class LedWrapper *********************************************************************************/function LedWrapper(pID, pGroupItems){    this.id = pID;    this.type = NODE_TYPE_LED;    this.tag = "LED_" + this.id;    pGroupItems.name = this.tag;        this.ledTextFrame = pGroupItems.textFrames.getByName(ledColorTextName);        // get the originalAngle of this LED before running our script    originalAngle = getTextFrameAngleMatrix(this.ledTextFrame);    // rotate this LED back to vertical axis so that following assignment is correct    // we will rotate this LED back to its originalAngle after all the initiations have finished    // the reason for this trick is that in the first place, the initiations of all other properties    // are made based on an asumption that LED is vertically aligned.    pGroupItems.rotate((-1)*originalAngle);    this.groupItems = pGroupItems;    this.ledFrame = pGroupItems.pathItems.getByName(ledOuterObjectName);    this.ledBody = pGroupItems.pathItems.getByName(ledObjectName);        this.anodePad = pGroupItems.pathItems.getByName(ledAnodePadName);    this.cathodePad = pGroupItems.pathItems.getByName(ledCathodePadName);    this.innerPad;    this.outerPad;    this.inWidth = DEFAULT_LINE_WIDTH;    this.outWidth = DEFAULT_LINE_WIDTH;    this.aioW = [DEFAULT_LINE_WIDTH, DEFAULT_LINE_WIDTH]; // anode in/out width, [0] is out, [1] is in    this.cioW = [DEFAULT_LINE_WIDTH, DEFAULT_LINE_WIDTH]; // cathode in/out width, [0] is out, [1] is in    this.ioW = [this.cioW, this.aioW]; //cathode, anode in/out width index [0] is cathode, index [1] is anode        this.center = {x:0, y:0};    this.center.x = point2mm(Math.abs(this.ledFrame.position[0])) + ledFrameW/2;    this.center.y = (-1) * (point2mm(Math.abs(this.ledFrame.position[1])) + ledFrameH/2);    this.anode = {};    this.anode.x = this.center.x;    this.anode.y = (-1) * (point2mm(Math.abs(this.ledBody.position[1])));    this.cathode = {};    this.cathode.x = this.center.x;    this.cathode.y = (-1) * (point2mm(Math.abs(this.ledBody.position[1])) + ledH);    this.polarPoint = [this.cathode, this.anode];    this.anodeNormalizedVector = normalizeVector({x:this.anode.x - this.center.x, y:this.anode.y - this.center.y});    var a = [];    for(var i=0;i<this.anodePad.geometricBounds.length;i++){        a.push(point2mm(this.anodePad.geometricBounds[i]));    }    this.anodePadRect = [new LineSegment({x:a[0], y:a[3]}, {x:a[0], y:a[1]}), //left                         new LineSegment({x:a[0], y:a[1]}, {x:a[2], y:a[1]}), //top                         new LineSegment({x:a[2], y:a[1]}, {x:a[2], y:a[3]}), //right                         new LineSegment({x:a[2], y:a[3]}, {x:a[0], y:a[3]})]; //bottom    this.anodeCenter = new MyPoint(this.anode.x, (-1)*Math.abs(a[1] + a[3])/2);    this.anodePadRectPoints = [{x: a[0], y: a[1]},                                {x: a[2], y: a[1]},                               {x: a[2], y: a[3]},                               {x: a[0], y: a[3]}];    var b = [];    for(var i=0;i<this.cathodePad.geometricBounds.length;i++){        b.push(point2mm(this.cathodePad.geometricBounds[i]));    }    this.cathodePadRect = [new LineSegment({x:b[2], y:b[1]}, {x:b[2], y:b[3]}),                           new LineSegment({x:b[2], y:b[3]}, {x:b[0], y:b[3]}),                           new LineSegment({x:b[0], y:b[3]}, {x:b[0], y:b[1]}),                           new LineSegment({x:b[0], y:b[1]}, {x:b[2], y:b[1]})];    this.cathodeCenter = new MyPoint(this.cathode.x, (-1)*Math.abs(b[1] + b[3])/2);    this.cathodePadRectPoints = [{x: b[2], y: b[3]},                                 {x: b[0], y: b[3]},                                 {x: b[0], y: b[1]},                                  {x: b[2], y: b[1]}];    this.polarsRect = [this.cathodePadRect, this.anodePadRect]; // index [0] is cathodePadRect, index [1] is anodePadRect    this.polarsRectPoint = [this.cathodePadRectPoints, this.anodePadRectPoints];    this.ends = [this.cathode, this.anode];    this.aioR = [DEFAULT_RESISTANCE, DEFAULT_RESISTANCE];    this.cioR = [DEFAULT_RESISTANCE, DEFAULT_RESISTANCE];    this.ioR = [this.cioR, this.aioR];    this.axis = new LineSegment(this.center, this.anode);    this.bisectorAngle = -1;    logTerminalln("wow: " + this.cathodePadRectPoints);    this.distanceTo = function(pLedWrapper){        xDistance = Math.abs(this.center.x - pLedWrapper.center.x);        yDistance = Math.abs(this.center.y - pLedWrapper.center.y);        return Math.sqrt(xDistance*xDistance + yDistance*yDistance);    };    this.rotate = function(pAngle){        this.groupItems.rotate(pAngle);        this.ledFrame = this.groupItems.pathItems.getByName(ledOuterObjectName);        this.ledBody = pGroupItems.pathItems.getByName(ledObjectName);        this.anodePad = pGroupItems.pathItems.getByName(ledAnodePadName);        this.cathodePad = pGroupItems.pathItems.getByName(ledCathodePadName);                this.anode = rotatePoint(this.center, this.anode, pAngle);        this.cathode = rotatePoint(this.center, this.cathode, pAngle);        this.ends[0] = this.cathode;        this.ends[1] = this.anode;        this.polarPoint[0] = this.cathode;        this.polarPoint[1] = this.anode;        this.anodeNormalizedVector = normalizeVector({x:this.anode.x - this.center.x, y:this.anode.y - this.center.y});        for(var i=0;i<this.anodePadRect.length;i++){            this.anodePadRect[i] = this.anodePadRect[i].rotate(this.center, pAngle);            this.cathodePadRect[i] = this.cathodePadRect[i].rotate(this.center, pAngle);        }        this.polarsRect[0] = this.cathodePadRect;        this.polarsRect[1] = this.anodePadRect;        for(var i=0;i<this.anodePadRectPoints.length;i++){            this.anodePadRectPoints[i] = rotatePoint(this.center, this.anodePadRectPoints[i], pAngle);            this.cathodePadRectPoints[i] = rotatePoint(this.center, this.cathodePadRectPoints[i], pAngle);        }        this.polarsRectPoint[0] = this.cathodePadRectPoints;        this.polarsRectPoint[1] = this.anodePadRectPoints;        this.axis = this.axis.rotate(this.center, pAngle);        this.anodeCenter = this.anodeCenter.rotatingPoint(this.center, pAngle);        this.cathodeCenter = this.cathodeCenter.rotatingPoint(this.center, pAngle);    };    // rotate LED back to its originalAngle as we has rotate it in the constructor     // of this LedWrapper class    this.rotate(originalAngle);    this.getHorizontalAngle = function() {        var theta = this.ledTextFrame.matrix.mValueB >= 0 ?                    rad2degree(Math.acos(this.ledTextFrame.matrix.mValueA)) :                    -rad2degree(Math.acos(this.ledTextFrame.matrix.mValueA));        return theta + 90;    };    this.getWiderTrace = function(pPolar) {        return this.ioW[pPolar][0] > this.ioW[pPolar][1] ?               this.ioW[pPolar][0] : this.ioW[pPolar][1];    };    this.highlightAnodeCathode = function(){    };}